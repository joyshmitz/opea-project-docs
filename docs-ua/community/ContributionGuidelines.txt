# Посібник із здійснення внесків

Дякуємо, що розглядаєте можливість долучитися до проекту OPEA.
Процес внесення пропозицій подібний до інших проектів з відкритим вихідним кодом на Github,
що передбачає відкрите обговорення проблем і запитів щодо функцій між супровідниками, дописувачами та користувачами.

Як проект з відкритим вихідним кодом, ми вітаємо і заохочуємо спільноту надсилати патчі безпосередньо до проекту.
У нашому спільному середовищі з відкритим вихідним кодом стандарти і методи подання змін допомагають зменшити хаос,
який може виникнути в результаті активної спільноти розробників.

Цей документ пояснює, як брати участь в обговореннях проекту, реєструвати помилки і запити на поліпшення,
а також надсилати виправлення до проекту, щоб ваші виправлення були швидко прийняті в кодову базу.

## Підтримка

- Не соромтеся звертатися за підтримкою на [opea@opea.dev] (mailto: info@opea.dev).
- Надсилайте свої запитання, запити на розробку та повідомлення про помилки на сторінку проблем GitHub.

## Contributor Covenant Code of Conduct

Цей проєкт має на меті стати безпечним, гостинним простором для співпраці,
і очікується, що його учасники дотримуватимуться наступних правил
[Contributor Covenant Code of Conduct](./CODE_OF_CONDUCT.md).

## Обговорення у спільноті

Розробникам пропонується взяти участь в обговоренні, відкривши тему в
одному з репозиторіїв GitHub за адресою
[github.com/opea-project](https://github.com/opea-project). Крім того, ви можете надіслати
електронного листа на адресу [info@opea.dev](mailto:info@opea.dev) або підпишіться на
[X/Twitter](https://twitter.com/opeadev) або
[LinkedIn](https://www.linkedin.com/company/opeadev/posts/?feedView=all), щоб отримувати
останні новини про проєкт OPEA.

## Документація

Якість документації проекту OPEA може мати величезний вплив на його успіх.
Ми закликаємо супровідників та дописувачів OPEA створювати чітку, детальну та актуальну документацію для користувачів.

## Ліцензування

Ліцензування дуже важливе для проектів з відкритим кодом.
Воно допомагає гарантувати, що програмне забезпечення продовжує бути доступним на умовах, які бажав автор.

.. _Apache 2.0 license:
   https://github.com/opea-project/License/blob/main/LICENSE.txt

.. _GitHub repo: https://github.com/opea-project

OPEA використовує [Apache 2.0 license](https://github.com/opea-project/License/blob/main/LICENSE.txt)
(як можна знайти у файлі LICENSE у
[GitHub Repos](https://github.com/opea-project), щоб досягти балансу між відкритим
внеском і можливістю використовувати програмне забезпечення так, як ви бажаєте.
використовувати програмне забезпечення так, як ви бажаєте.
Ліцензія Apache 2.0 - це дозвільна ліцензія з відкритим вихідним кодом, яка
дозволяє вам вільно використовувати, змінювати, розповсюджувати і продавати ваші власні продукти
до складу яких входить програмне забезпечення під ліцензією Apache 2.0.

Ліцензія вказує вам, які права ви маєте як розробник, як це передбачено
власником авторських прав. Важливо, щоб дописувач повністю розумів
ліцензійні права та погодився з ними. Іноді власник авторських прав не є автором, наприклад,
коли автор виконує роботу від імені компанії.

### Компоненти, що використовують інші ліцензії

Імпорт коду до проекту OPEA з інших проектів, які використовують ліцензію, 
відмінну від ліцензії Apache 2.0, має бути повністю зрозумілим у контексті та схваленим правлінням OPEA.

Ретельно перевіряючи потенційні внески, а також забезпечуючи дотримання DCO для наданого коду,
ми можемо гарантувати, що спільнота OPEA може розробляти продукти в рамках проекту OPEA,
не турбуючись про патентні та авторські права.

## Повідомлення про авторські права

Будь ласка, дотримуйтесь цих [Community Best Practice](https://www.linuxfoundation.org/blog/copyright-notices-in-open-source-software-projects/)
для отримання повідомлень про авторські права від Linux Foundation.

## Сертифікація походження розробника (DCO)

Для того, щоб добросовісно забезпечити дотримання критеріїв ліцензування, 
проект OPEA вимагає дотримання процедури отримання сертифікату походження розробника (DCO).

DCO - це сертифікат, який додається до кожного внеску, зробленого кожним
розробником. У повідомленні про фіксацію внеску (більш детально описано
далі у цьому документі), розробник просто додає ``Підписано``
і тим самим погоджується з DCO.

Коли розробник подає патч, він зобов'язується, що учасник має право подати патч згідно з ліцензією.
Угоду DCO показано нижче та на [developercertificate.org](http://developercertificate.org/).

```
Developer's Certificate of Origin 1.1

By making a contribution to this project, I certify that:

(a) Внесок був створений повністю або частково мною, і я маю право подати його на умовах ліцензії з відкритим вихідним кодом, зазначеної у файлі; або

(b) Внесок базується на попередній роботі, яка, наскільки мені відомо, поширюється під відповідною ліцензією з відкритим вихідним кодом,
    і я маю право за цією ліцензією подавати цю роботу зі змінами, створеними повністю або частково мною,
    під тією ж ліцензією з відкритим вихідним кодом (якщо мені не дозволено подавати роботу під іншою ліцензією), як зазначено у файлі; або

(c) Внесок був наданий мені безпосередньо іншою особою, яка засвідчила (a), (b) або (c), і я не змінював його.

(d) Я розумію і погоджуюся, що цей проект і мій внесок є публічними, і що запис про мій внесок (включаючи всю особисту інформацію,
    яку я надаю разом з ним, включаючи мій підпис) зберігається протягом невизначеного терміну і може бути розповсюджений 
    відповідно до цього проекту або ліцензії з відкритим вихідним кодом, що використовується.
```

### Підписання DCO

Підписанням у DCO є рядок `Signed-off-by:` у повідомленні журналу кожного комміту.
Рядок Signed-off-by: повинен мати наступний формат:

```
Signed-off-by: Your Name <your.email@example.com>
```

Для ваших коммітів замініть:

- `Your Name` з вашим юридичним ім'ям (псевдоніми, хакерські псевдоніми та назви груп не допускаються)

- `your.email@example.com` з тією ж адресою електронної пошти, яку ви використовуєте для авторизації комміту (CI зазнає невдачі, якщо вона не збігається).

Ви можете автоматично додати рядок Signed-off-by: до тіла коміту за допомогою `git commit -s`. Використовуйте інші комміти в історії opea git як приклади.

Додаткові вимоги:

- Якщо ви змінюєте існуючий коміт, створений кимось іншим, ви повинні додати свій рядок Signed-off-by:, не видаляючи існуючий.

- Якщо ви забули додати рядок Signed-off-by:, ви можете додати його до попереднього коміту, виконавши `git commit --amend -s`.

- Якщо ви вже виклали свої зміни на GitHub, вам потрібно буде примусово проштовхнути гілку після цього за допомогою `git push -f`.

### Примітки

Будь-які внески, зроблені в рамках поданих запитів, вважаються вільними для використання Проєктом.
Розробникам дозволяється вибирати патчі, включені до запитів, поданих іншими учасниками. Очікується, що

* вміст патчів не буде суттєво змінено,
* відібрані комміти або частини коммітів повинні зберігати оригінальні повідомлення про підписання й особистість автора.

## Передумови

Як учасник, ви повинні бути знайомі з проєктом OPEA, знати, як його налаштувати, встановити і використовувати, а також як налаштувати своє середовище розробки.

Ви повинні бути знайомі з поширеними інструментами для розробників, такими як Git, і платформами, такими як GitHub.

## Пропонування нові функції

Спільноти OPEA використовують процес RFC (запит на коментарі) для спільної роботи над суттєвими змінами в проектах OPEA. 
Процес RFC дозволяє учасникам співпрацювати під час процесу розробки, забезпечуючи ясність і перевірку перед тим, як перейти до реалізації.

Процес RFC необхідний для змін, які мають значний вплив на кінцевих користувачів, робочий процес або API, орієнтований на користувача.

Він в основному включає:

- Зміни в основному робочому процесі.
- Зміни зі значними архітектурними наслідками.
- Зміни, які модифікують або впроваджують інтерфейси, орієнтовані на користувача.

Це не обов'язково для таких змін, як:

- Виправлення помилок і оптимізація без семантичних змін.
- Невеликі функції, які не передбачають зміни робочого процесу або інтерфейсу і впливають лише на вузьку область використання.

Покрокові інструкції
####################

- Дотримуйтесь [RFC Template](./rfc_template.md), щоб запропонувати свою ідею.
- Подати пропозицію на сторінку `Issues` відповідного репозиторію OPEA на github.
- Якщо вам потрібна допомога з процесом створення RFC, зверніться до його правонаступника..
- Внести зміни у вашу заявку у відповідь на відгуки рецензента.


Pull-Запити і проблеми
**********************

Подання Pull-Запитів
####################

Створення Pull-Запитів
######################

Якщо у вас є ідеї щодо покращення проектів OPEA, надсилайте свої запити до кожного проекту на розгляд.
Якщо ви новачок на GitHub, перегляньте про pull-запити [How To](https://help.github.com/articles/using-pull-requests/).

Покрокові інструкції
####################

- Поставте "зірку" цьому репозиторію використовуючи кнопку `Star` в верхньому правому кутку.
- Зробіть форк відповідного репозиторію OPEA за допомогою кнопки `Fork` у верхньому правому кутку.
- Клонуйте ваш форкований репозиторій на ваш ПК, виконавши `git clone "url to your repo"`.
- Створіть нову гілку для ваших змін, виконавши `git checkout -b new-branch`.
- Додайте файли командою `git add -A`, зафіксуйте `git commit -s -m "Це моє повідомлення про фіксацію"` і проштовхніть `git push origin new-branch`.
- Створіть "pull request" для проекту, до якого ви хочете долучитися.

Шаблон Pull-Запиту
##################

Дивиться [PR template](./pull_request_template.md)

Критерії прийняття Pull-Запиту
##############################

- Щонайменше два схвалення від рецензентів

- Проходження всіх виявлених перевірок стану

- Всі розмови вирішені

- Сумісність із ліцензіями сторонніх розробників

Огляд перевірок стану Pull-Запиту
#################################

Проєкти OPEA використовують GitHub Action для тестування CI.

| Ім'я Тесту              | Сфера тестування                              | Критерії проходження тесту |
|-------------------------|-----------------------------------------------|----------------------------|
| DCO                     | Використовуйте `git commit -s` для підписання | PASS                       |
| Сканування формату коду | pre-commit.ci [Bot]                           | PASS                       |
| Сканування безпеки коду | Bandit/Hadolint/Dependabot/CodeQL/Trellix     | PASS                       |
| Юніт-тест               | Юніт-тест у папці з тестом                    | PASS                       |
| Наскрізний тест         | Наскрізний робочий процес тестування          | PASS                       |

- [Developer Certificate of Origin (DCO)](https://en.wikipedia.org/wiki/Developer_Certificate_of_Origin), PR повинен погодитися з умовами Developer Certificate of Origin, підписавши кожну з коммітів за допомогою `-s`, наприклад, `git commit -s -m 'Це моє повідомлення про комміти'..
- Юніт-тест, PR повинен пройти всі юніт-тести і без регресії покриття.
- Наскрізний тест, PR повинен пройти всі наскрізні тести.
  - Якщо основний реліз запроваджує новий мікросервіс для `GenAIComps`, то основний реліз повинен включати нові наскрізні тести. Назва тестового скрипту має збігатися з назвою теки, щоб тест автоматично запускався структурою тесту, наприклад, якщо новий сервіс `GenAIComps/comps/dataprep/redis/langchain`, то назва тестового скрипту має бути `GenAIComps/tests/test_dataprep_redis_langchain.sh`..
  - Якщо PR вводить новий приклад для `GenAIExamples`, то PR повинен включати нові приклади наскрізних тестів. Назва тестового скрипту має збігатися з назвою прикладу, щоб тест автоматично запускався структурою тесту, наприклад, якщо приклад `GenAIExamples/ChatQnA`, то назва тестового скрипту має бути `ChatQnA/tests/test_chatqna_on_gaudi.sh` і `ChatQnA/tests/test_chatqna_on_xeon.sh`..

Огляд Pull-Запиту
#################
Ви можете додати рецензентів зі [the code owners list](../codeowner.md) до свого PR.


.. _OPEA Project Issues: https://github.com/search?q=org%3Aopea-project+%2Fissues&type=issues

.. _open pull requests: https://github.com/opea-project/GenAIComps/pulls

.. _OPEA Technical Discuss:  mailing list: https://lists.lfaidata.foundation/g/OPEA-technical-discuss


Перш ніж розпочати роботу над патчем, спершу перевірте наші проблеми у `OPEA Project Issues`_system,
щоб побачити, що було повідомлено про проблему, яку ви хочете вирішити. Зробить спілкування про те, що інші думають про вашу проблему
(і запропоноване рішення) на `OPEA Technical Discuss`. Ви можете знайти інших людей, які зіткнулися з проблемою, яку ви шукаєте, або які мають
схожі ідеї щодо змін або доповнень.  Надішліть повідомлення в `OPEA Technical Discuss`, щоб представити і обговорити вашу ідею з спільнотою розробників.

Завжди корисно шукати вже існуючі або пов'язані питання перед тим, як надсилати свій власний.
Коли ви надсилаєте проблему (запит на виправлення помилки або функціонал), команда сортування розгляне і прокоментує заявку, як правило, протягом декількох робочих днів.

Ви можете знайти всі `open pull requests`_ на GitHub і відкрити `OPEA Project Issues_ в  GitHub issues.


### Повідомлення о проблемах

Якщо користувач OPEA зіткнувся з якоюсь несподіваною поведінкою, найкраще повідомити про проблему на сторінці `Issues` у відповідному github-проєкті. Будь ласка, переконайтеся, що у списку проблем немає подібної проблеми.) Будь ласка, дотримуйтесь шаблону повідомлення про помилку і надайте якомога більше інформації, а також будь-які додаткові відомості, які ви можете мати. Буде корисно, якщо автор повідомлення зможе звузити проблемну поведінку до мінімального відтворюваного тестового кейсу.

.. _git_setup:

Git Налаштування
****************

Нам потрібно знати, хто ви і як з вами зв'язатися. Щоб додати цю інформацію до вашої інсталяції Git'у,
встановіть у конфігураційних змінних Git'у ``user.name`` ваше повне ім'я,
а в ``user.email`` - адресу вашої електронної пошти.

Наприклад, якщо ваше ім'я ``OPEA Developer`` і ваша електронна адреса ``opea.developer@example.com``:

.. code-block:: console

   git config --global user.name "OPEA Developer"
   git config --global user.email "opea.developer@example.com"


Посібник з Pull-Запиту
**********************
Відкриваючи новий запит на відкликання, дотримуйтесь наступних рекомендацій, щоб забезпечити
дотримання стандартів OPEA та полегшення процесу розгляду.

Якщо у вас є сумніви, рекомендуємо ознайомитися з існуючими pull-запитами на вилучення в репозиторії OPEA.
Використовуйте пошукові фільтри та мітки, щоб знайти PR, пов'язані зі змінами подібні до тих, які ви пропонуєте.

.. _commit-guidelines:

Посібник з Повідомлень Коммітів
===============================

Зміни подаються у вигляді Git-коммітів. Кожен комміт має *повідомлення про комміт*, що описує зміну. Прийнятні повідомлення про комміти виглядають наступним чином:

.. code-block:: none

   [area]: [summary of change]

   [Commit message body (must be non-empty)]

   Signed-off-by: [Your Full Name] <[your.email@address]>

Вам потрібно змінити текст у квадратних дужках (``[ось так]``) вище, щоб він відповідав вашому комміту.

Приклади та більш детальна інформація наведені нижче.

Приклад
-------

Ось приклад хорошого повідомлення комміта.

.. code-block:: none

   drivers: sensor: abcd1234: fix bus I/O error handling

   The abcd1234 sensor driver is failing to check the flags field in
   the response packet from the device which signals that an error
   occurred. This can lead to reading invalid data from the response
   buffer. Fix it by checking the flag and adding an error path.

   Signed-off-by: OPEA Developer <opea.developer@example.com>

[area]: [summary of change]
---------------------------

Цей рядок називається *назвою* коміту. Назва має бути обов'язковою:

* один рядок
* довжиною менше 72 символів
* за яким слідує абсолютно порожній рядок

[area]
  Префікс ``[area]`` зазвичай визначає область коду,  що змінюється. 
  Він також може визначати ширший контекст зміни, якщо вона зачіпає кілька областей.

  Ось кілька прикладів:

  * ``doc: ...`` для внесення змін до документації
  * ``drivers: foo:`` для ``foo`` зміни драйверів
  * ``Bluetooth: Shell:`` для внесення змін до оболонки Bluetooth
  * ``net: ethernet:`` для змін у мережі, пов'язаних з Ethernet
  * ``dts:`` для змін у всьому дереві пристроїв
  * ``style:`` для зміни стилю коду

  Якщо ви не впевнені, що використовувати, спробуйте виконати ``git log FILE``, де
  ``FILE`` - це файл, який ви змінюєте, і використовуючи попередні комміти, які
  змінювали той самий файл як приклад.

[summary of change]
  Частина ``[summary of change]`` має бути коротким описом того, що ви зробили. Ось кілька прикладів:

  * ``doc: оновлено вікі-посилання на новий сайт``
  * ``drivers: sensor: sensor_shell: виправлено колізію назв каналів``

Тіло повідомлення комміту
-------------------------

.. попередження::

   Порожнє тіло повідомлення комміту не допускається. Навіть для тривіальних
   змін, будь ласка, додайте описовий текст повідомлення комміту. Ваш
   pull-запит не пройде перевірку CI, якщо ви не вкажете його.

Ця частина комміту повинна пояснювати, що робить ваша зміна, і чому
вона потрібна. Будьте конкретними. Тіло, у якому сказано «Виправляє щось», буде
відхилено. Не забудьте включити наступне, якщо це доречно:

* **що** зміна робить,
* **чому** ви обрали такий підхід,
* **що** були зроблені припущення, і
* **як** ви знаєте, що це працює - наприклад, які тести ви провели.

Кожен рядок у вашому повідомленні комміту зазвичай повинен містити не більше 75 символів.
Використовуйте нові рядки для завершення довгих рядків. 
Винятки становлять рядки з довгими URL-адресами, адресами електронної пошти тощо.

Приклади прийнятих повідомлень про комміти можна знайти
в OPEA GitHub `changelog <https://github.com/opea-project/commits/main>`__.


Підписано: ...
--------------

.. tip::

   Ви вже мали б встановити свій :ref:`git_setup`. 
   Створіть ваш комміт за допомогою ``git commit -s``,
   щоб автоматично додати рядок Signed-off-by:, використовуючи цю інформацію.

З міркувань ліцензування відкритого вихідного коду,
ваш комміт повинен містити рядок Signed-off-by:, який виглядає наступним чином:

.. code-block:: none

   Signed-off-by: [Your Full Name] <[your.email@address]>

Наприклад, якщо ваше повне ім'я ``OPEA Developer`` і ваша електронна адреса ``opea.developer@example.com``.:

.. code-block:: none

   Signed-off-by: OPEA Developer <opea.developer@example.com>

Це означає, що ви особисто переконалися, що ваша зміна відповідає :ref:`DCO`.
З цієї причини ви повинні використовувати своє юридичне ім'я. 
Псевдоніми або "хакерські псевдоніми" не допускаються.

Ваше ім'я та адреса електронної пошти, які ви використовуєте,
повинні збігатися з ім'ям та адресою у полі ``Author:`` коміту Git'а.

Дивіться :ref:`contributor-expectations` 
для більш повного обговорення очікувань дописувачів та рецензентів.

Додавання посилань
------------------

.. _GitHub references:
   https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/autolinked-references-and-urls

Не включайте `GitHub references`_ безпосередньо у повідомлення про коммітування, оскільки це може
це може втратити сенс, наприклад, у випадку розгалуження репозиторію. Замість цього, якщо зміна
стосується конкретної проблеми GitHub, включіть в повідомлення Pull Request
рядок виду:

.. code-block:: none

   Fixes #[issue number]

Де ``[issue number]`` номер відповідної проблеми GitHub. 
Наприклад:

.. code-block:: none

   Fixes: #1234

Ви можете вказати на іншу відповідну інформацію, яку можна знайти в Інтернеті,
використовуючи теги :code:`Link:`. Це включає, наприклад: проблеми GitHub, даташити,
довідкові посібники тощо.

.. code-block:: none

   Link: https://github.com/opea-project/genAIComps/issues<issue number>

.. _coding_style:

Стиль кодування
===============

.. _Linux kernel coding style:
   https://kernel.org/doc/html/latest/process/coding-style.html

Загалом, дотримуйтесь `стилю кодування ядра Linux`_, за наступними винятками:

* Довжина рядка - 100 стовпців або менше.
  У документації довші рядки для посилань на URL-адреси є дозволеним винятком.
* Додайте дужки до кожного оператора ``if``, ``else``, ``do``, ``while``, ``for`` і ``witch``,
  навіть для однорядкових блоків коду.
  Використовуйте прапорець ``--ігнорувати BRACES``, щоб змусити *checkpatch* припинити скаржитися.
* Використовуйте пробіли замість табуляції для вирівнювання коментарів після декларацій, якщо потрібно.
* Використовуйте однорядкові коментарі у стилі C89, ``/* */``.
  Однорядковий коментар у стилі C99, ``//``, не допускається.
* Використовуйте ``/** */`` для коментарів щодо доксигену, які мають з'явитися у документації.
* Уникайте використання бінарних літералів (констант, що починаються з ``0b``).
* Уникайте використання не-ASCII символів у коді, якщо тільки це суттєво не покращує зрозумілість,
  і в будь-якому випадку уникайте смайликів.

Використовуйте ці рекомендації щодо кодування, щоб переконатися,
що ваша розробка відповідає стилю проекту та угодам щодо іменування.

Для перевірки відповідності стилю коду ядра Linux використовується інструмент ``checkpatch`` з ліцензією GPL.

.. note::
   checkpatch наразі не запускається на Windows.

Чекпатч доступний у каталозі скриптів. Щоб викликати його при фіксації коду,
зробіть файл *$OPEA_BASE/.git/hooks/pre-commit* виконуваним і відредагуйте його так, щоб він містив:

.. code-block:: bash

    #!/bin/sh
    set -e exec
    exec git diff --cached | ${OPEA_BASE}/scripts/checkpatch.pl -

Замість того, щоб запускати чекпатч при кожному комміті, ви можете запускати його тільки перед тим,
як виставляти репо OPEA. Для цього зробіть файл *$OPEA_BASE/.git/hooks/pre-push* виконуваним
і відредагуйте його так, щоб він містив:

.. code-block:: bash

    #!/bin/sh
    remote="$1"
    url="$2"

    z40=0000000000000000000000000000000000000000

    echo "Run push hook"

    while read local_ref local_sha remote_ref remote_sha
    do
        args="$remote $url $local_ref $local_sha $remote_ref $remote_sha"
        exec ${OPEA_BASE}/scripts/series-push-hook.sh $args
    done

    exit 0

Якщо ви хочете відмінити вердикт checkpatch і проштовхнути гілку, незважаючи на повідомлені проблеми,
ви можете додати опцію --no-verify до команди git push.

Повнішою альтернативою цьому є використання :ref:`check_compliance_py` скрипта.

clang-format
------------

Інструмент `clang-format <https://clang.llvm.org/docs/ClangFormat.html>`_ може бути корисним
для швидкого переформатування великих обсягів нового вихідного коду
відповідно до наших стандартів `Coding Style`_ разом з файлом конфігурації ``.clang-format``,
що надається у сховищі. ``clang-format`` добре інтегровано у більшість редакторів,
але ви також можете запустити його вручну таким чином:

.. code-block:: bash

   clang-format -i my_source_file.c

``clang-format`` є частиною LLVM, яку можна завантажити з проєкту
``releases page <https://github.com/llvm/llvm-project/releases>`_. Зауважте, що якщо
ви користувач Linux, ``clang-format``, ймовірно, буде доступно у вигляді пакунка у
репозиторіях вашого дистрибутива.

Якщо існують відмінності між настановами `Стилю кодування`_ та
форматуванням, створеним інструментами форматування коду, настанови `Стилю кодування`_ мають перевагу.
Якщо існує неоднозначність між інструментами форматування і настановами, супроводжувачі можуть вирішити,
який стиль слід застосовувати.

.. _Continuous Integration:

Безперервна інтеграція (CI)
===========================

Проєкт OPEA використовує систему безперервної інтеграції (CI), яка працює на
кожного Pull-запиту (PR) з метою перевірки декількох аспектів PR:

* Форматування коммітів Git'а
* Стиль кодування
* Збірки Twister для різних архітектур і плат
* Збірка документації для перевірки будь-яких змін у документації

CI виконується на Github Actions і використовує ті ж інструменти, що описані в розділі `Тести CI`_.
Результати CI повинні бути зеленими, що означає "Всі перевірки пройдено", перш ніж Pull-запит буде об'єднано.
CI виконується при створенні PR, а також кожного разу, коли PR змінюється за допомогою комміту.

Поточний статус прогону КІ завжди можна знайти внизу сторінки GitHub PR, під статусом рецензії.
Залежно від успіху чи невдачі, ви побачите, чи був запуск успішним:

* "All checks have passed"
* "All checks have failed"

У разі невдачі ви можете натиснути на посилання «Details», представлене під
повідомлення про помилку, щоб перейти до «Github Actions» і переглянути
результати.
Після натискання на посилання ви потрапите на підсумкову сторінку ``Github actions``
де буде показано таблицю з усіма різними збірками. Щоб побачити
яка збірка або тест не пройшли, натисніть на рядок, що містить невдалу (тобто
незелену) збірку.

.. _CI Tests:

Запуск тестів CI локально
=========================

.. _check_compliance_py:

check_compliance.py
-------------------

Скрипт ``check_compliance.py`` слугує цінним інструментом для оцінки відповідності коду
встановленим керівним принципам та найкращим практикам OPEA. Цей скрипт є обгорткою для набору інструментів,
які виконують різні перевірки, зокрема, лінтерів і форматорів.

Розробникам рекомендується запустити скрипт локально, щоб перевірити свої зміни,
перш ніж відкривати новий Pull-запит:

.. code-block:: bash

   ./scripts/ci/check_compliance.py -c upstream/main..

twister
-------

.. note::
   twister повністю підтримується тільки на Linux;
   на Windows і MacOS виконання тестів не підтримується, тільки збірка.

Якщо ви вважаєте, що ваша зміна може порушити якийсь тест, ви можете подати свій PR як чернетку
і дозволити CI проекту автоматично запустити :ref:`twister_script` для вас.

Якщо тест не пройшов, ви можете перевірити в журналах запуску CI, як повторити його локально, наприклад:

.. code-block:: bash

   west twister -p native_sim -s tests/drivers/build_all/sensor/sensors.generic_test

.. _static_analysis:

Статичний аналіз коду
*********************

Coverity Scan - це безкоштовний сервіс для статичного аналізу коду проектів з відкритим вихідним кодом.
Він базується на комерційному продукті Coverity і може аналізувати код на C, C++ та Java.

Статичний аналіз коду в Coverity не виконує код. Замість цього він використовує
абстрактну інтерпретацію, щоб отримати інформацію про потік управління коду і
потоку даних. Він здатний простежити всі можливі шляхи коду, якими може піти програма.
Наприклад, аналізатор розуміє, що malloc() повертає пам'ять, яка повинна бути
звільнити за допомогою функції free(). Він простежує всі розгалуження і виклики функцій, щоб побачити
чи всі можливі комбінації звільняють пам'ять. Аналізатор здатний виявити
різноманітні проблеми, такі як витік ресурсів (пам'яті, файлових дескрипторів), NULL
розіменування, використання після вільного, неперевірені значення, що повертаються, мертвий код, переповнення буфера, цілочисельні переповнення, неініціалізовані змінні та багато інших.

Результати доступні на сайті `Coverity Scan <https://scan.coverity.com/projects/OPEA>`_.
Для того, щоб отримати доступ до результатів, вам необхідно створити власний обліковий запис.
На сторінці проекту OPEA ви можете вибрати "Додати мене до проекту", щоб бути доданим до проекту.
Нові учасники повинні бути схвалені адміністратором.

Статичний аналіз кодової бази OPEA проводиться раз на два тижні. GitHub
проблеми автоматично створюються для всіх проблем, виявлених інструментами статичного аналізу.
Ці проблеми матимуть однаковий (або еквівалентний) пріоритет, визначений інструментом.

Для забезпечення підзвітності та ефективного вирішення проблем,
вони призначаються відповідному супровіднику, який відповідає за відповідний код.

Спеціальна команда, що складається з експертів у галузі статичного аналізу,
якості коду та безпеки програмного забезпечення, забезпечує ефективність процесу статичного
аналізу та перевіряє, що виявлені проблеми належним чином сортуються та вирішуються вчасно.

Робочий процес
==============

Якщо після аналізу звіту про покриття зроблено висновок, що він є хибно
позитивним, будь ласка, встановіть класифікацію на «False positive» або
«Intentional», дію “Ignore”, власника у власному обліковому записі та додайте
коментарій, чому проблема вважається хибнопозитивною або навмисною.

Оновіть відповідну тему на Github у проєкті OPEA з деталями і закрийте її лише після виконання
наведених вище кроків на сайті сервісу сканування. Будь-які проблеми, закриті без виправлення або
без ігнорування запису в сервісі сканування, будуть автоматично відкриті знову,
якщо проблема продовжує бути присутньою в коді.

.. _Contribution workflow:

Процес роботи з внесками
************************

Однією з загальних практик, яку ми заохочуємо, є внесення невеликих, контрольованих змін.
Така практика спрощує перевірку, полегшує злиття і перезавантаження,
а також зберігає історію змін чіткою і чистою.

При внесенні змін до проекту OPEA також важливо, щоб ви надали якомога більше інформації про ваші зміни,
оновили відповідну документацію та ретельно протестували ваші зміни перед поданням.

Загальний робочий процес на GitHub, який використовують розробники OPEA,
використовує комбінацію команд командного рядка Git і взаємодії браузера з GitHub.
Як і у випадку з Git'ом, існує декілька способів виконання завдання.
Ми опишемо типовий робочий процес тут:

.. _Створити вилку OPEA:
   https://github.com/opea-project#fork-destination-box

#. `Створить вилку OPEA`_
   на Вашому персональному акаунті на GitHub. (Натисніть на кнопку форка у верхньому правому куті сторінки репозиторію проекту OPEA на GitHub.)

#. На вашому комп'ютері для розробки перейдіть до теки :file:`OPEA`,
   яка була створена, коли ви :ref:`отримали код <get_the_code>`::

     cd opea-project

   Перейменуйте стандартний віддалений вказівник на `upstream репозиторій
   <https://github.com/opea-project>`_ з ``origin`` на
   ``upstream``::

     git remote rename origin upstream

   Повідомте Git'у про щойно створений форк, назвавши його ``origin``::

     git remote add origin https://github.com/<your github id>/opea-project

   і перевірте віддалені репозиторії::

     git remote -v

   Вивід повинен виглядати приблизно так::

     origin   https://github.com/<your github id>/opea-project (fetch)
     origin   https://github.com/<your github id>/opea-project (push)
     upstream https://github.com/opea-project (fetch)
     upstream https://github.com/opea-project(push)

#. Створіть тематичну гілку (поза ``main``) для своєї роботи (якщо ви вирішуєте
   проблему, радимо вказати номер проблеми в назві гілки)::

     git checkout main
     git checkout -b fix_comment_typo

   Деякі підсистеми OPEA розробляються на окремій гілці від
   ``main``, тому вам може знадобитися вказати це у вашому замовленні::

     git checkout -b fix_out_of_date_patch origin/net

#. Вносимо зміни, тестуємо локально,
   змінюємо, тестуємо, знову тестуємо, ... (див. також попередню главу про "твістер").

#. Коли все буде добре, запустіть процес pull-запиту, додавши змінені файли::

     git add [file(s) that changed, add -p if you want to be more specific]

   Ви можете переглянути файли, які ще не поставлені на сцену, за допомогою::

     git status

#. Переконайтеся, що зміни, які потрібно зафіксувати, виглядають так, як ви очікували::

     git diff --cached

#. Зафіксуйте зміни в локальному репозиторії::

     git commit -s

   Опція ``-s`` автоматично додає ваш рядок ``Signed-off-by:`` до вашого повідомлення про коммітування.
   Ваш комміт буде відхилено без цього рядка, який вказує на вашу згоду з :ref:`DCO`.
   Дивіться розділ :ref:`commit-guidelines` для отримання настанов щодо написання повідомлень про коммітування.

#. Перенесіть гілку теми зі змінами на форк в особистому акаунті GitHub::

     git push origin fix_comment_typo

#. У веб-браузері перейдіть до вашого форкованого репо і натисніть на кнопку
   ``Compare & pull request`` для гілки, над якою ви щойно працювали, і
   ви хочете відкрити pull-запит з ним.

#. Перегляньте зміни в запиті і переконайтеся, що ви відкриваєте запит для гілки ``main``.
   Також має з'явитися заголовок і повідомлення з вашого повідомлення про фіксацію.

#. Бот призначить одного або декількох запропонованих рецензентів (на основі файлу MAINTAINERS у репозиторії).
   Якщо ви є учасником проекту, ви також можете вибрати додаткових рецензентів зараз.

#. Натисніть кнопку "Надіслати", і ваш запит буде надіслано, він чекає на розгляд.
   По мірі надходження коментарів від рецензентів буде надіслано електронний лист,
   або ви можете перевірити свій запит на https://github.com/opea-project/pulls.

   .. note::По мірі об'єднання більшої кількості коммітів на сторінці PR GitHub
   з'явиться повідомлення "Ця гілка застаріла відносно базової гілки" і кнопка "Оновити гілку" на сторінці PR.
   Це повідомлення слід ігнорувати, оскільки коміти все одно будуть перезасновані в рамках злиття,
   а запуск оновлення гілки з інтерфейсу GitHub призведе до втрати схвалення PR-менеджера.

#. Поки ви чекаєте, поки ваш pull-запит буде прийнято і об'єднано, ви можете створити іншу гілку для роботи над іншим питанням.
   (Переконайтеся, що ваша нова гілка не пов'язана з ``головною``, а не з попередньою гілкою).::

     git checkout main
     git checkout -b fix_another_issue

  і використовуйте той самий процес, описаний вище, для роботи над новою гілкою теми.

#. Якщо рецензенти попросять внести зміни до вашого патчу, ви можете інтерактивно перезавантажити комміти,
   щоб виправити проблеми, пов'язані з рецензіями. У вашому репозиторії розробки::

     git rebase -i <offending-commit-id>^

   В інтерактивному редакторі ребази замініть ``pick`` на ``edit``, щоб вибрати
   конкретний комміт (якщо у вашому запиті на витягування їх декілька), або
   видаліть рядок, щоб повністю видалити комміт.  Потім відредагуйте файли, щоб виправити
   проблеми в огляді.

   Як і раніше, перевіряйте та тестуйте свої зміни. Коли все буде готово, продовжуйте надсилати патч::

     git add [file(s)]
     git rebase --continue

   Оновіть коментар коміту, якщо потрібно, і продовжуйте::

     git push --force origin fix_comment_typo

   Примусово відправивши оновлення, ваш початковий pull-запит буде оновлено вашими змінами,
   тому вам не потрібно буде повторно надсилати pull-запит.

#. Після того, як ви натиснете потрібну зміну, перевірте на сторінці PR, чи немає конфлікту злиття.
   Якщо так, перезавантажте локальну гілку::

      git fetch --all
      git rebase --ignore-whitespace upstream/main

   Параметр ``--ignore-whitespace`` забороняє ``git apply`` (викликаний командою rebase) змінювати пробіли.
   Вирішення конфліктів і повторна спроба::

      git push --force origin fix_comment_typo

   .. note:: Хоча внесення поправок до коммітів і форсування є поширеною моделлю рецензування
      за межами GitHub і рекомендована OPEA, вона не є основною
      моделлю, яку підтримує GitHub. Примусове виштовхування може спричинити неочікувану поведінку,
      наприклад, неможливість використання кнопок «Переглянути зміни», окрім останньої
      GitHub скаржиться, що не може знайти старіші комміти. Ви також не завжди
      завжди зможете порівняти останню переглянуту версію з останньою
      надісланою версією. При переписуванні історії GitHub гарантує доступ лише
      до останньої версії.


#. Якщо запуск CI не вдасться, вам потрібно буде внести зміни до вашого коду,
   щоб виправити проблеми і внести зміни до ваших комітів шляхом перебазування, як описано вище.
   Додаткову інформацію про систему CI можна знайти у розділі `Continuous Integration`_.

.. _contribution_tips:

Поради щодо внесків
===================

Нижче наведено список порад, які допоможуть покращити і пришвидшити процес розгляду Pull-запитів.
Якщо ви будете дотримуватися їх, швидше за все, ваш pull-запит отримає необхідну увагу
і буде готовий до злиття раніше, ніж пізніше:

.. _git-rebase:
   https://git-scm.com/docs/git-rebase#Documentation/git-rebase.txt---keep-base

#. Під час проштовхування подальших змін використовуйте опцію ``--keep-base`` у `git-rebase`_.

#. На сторінці PR перевірте, чи можна об'єднати зміни без конфліктів злиття

#. Переконайтеся, що назва PR пояснює, що саме виправляється або додається

#. Переконайтеся, що ваше PR-повідомлення має тіло з більш детальною інформацією про зміст вашої заявки

#. Переконайтеся, що ви посилаєтеся на проблему, яку ви виправляєте, в тілі PR

#. Переглядайте ранні результати аналізу відразу після подачі заявки та виправляйте помилки в міру їх виявлення

#. Поверніться до PR через 1-2 години, щоб побачити статус усіх перевірок КІ, переконайтеся, що всі вони зелені

#. Якщо ви отримали запит на внесення змін і надіслали зміни, щоб відповісти на нього,
   переконайтеся, що обов'язково натиснули кнопку «Re-request review» в інтерфейсі GitHub,
   щоб повідомити тих, хто просив про зміни


Визначення походження внеску
============================

Додаючи новий файл до дерева, важливо детально вказати джерело походження файлу,
надати атрибуцію та детальну інформацію про передбачуване використання.
У випадках, коли файл є оригіналом для OPEA,
повідомлення про фіксацію має містити наступне ("Оригінал" є припущенням, якщо тег Origin відсутній)::

      Origin: Original

У випадках, коли файл :ref:`імпортовано із зовнішнього проєкту <external-contributions>`,
повідомлення про коммітування має містити інформацію про оригінальний проєкт, місцезнаходження проєкту,
SHA-ідентифікатор оригінального комміту для файлу та його призначення.

Наприклад, копія локально збереженого імпорту::

      Origin: Contiki OS
      License: BSD 3-Clause
      URL: http://www.contiki-os.org/
      commit: 853207acfdc6549b10eb3e44504b1a75ae1ad63a
      Purpose:  of networking stack.

Наприклад, копія імпорту, що підтримується ззовні, у репозиторії модулів::

      Origin: Tiny Crypt
      License: BSD 3-Clause
      URL: https://github.com/01org/tinycrypt
      commit: 08ded7f21529c39e5133688ffb93a9d0c94e5c6e
      Purpose:  of TinyCrypt





