.. _doc_guidelines:

Керівництво з документації
##########################

Вміст проекту OPEA записується за допомогою мови `markdown`_ (``.md``) з розширеннями `MyST`_ та розмітки `reStructuredText`_,
а також обробляється за допомогою мови `Sphinx`_ для створення відформатованого автономного веб-сайту.  Розробники можуть
переглядати цей вміст або у сирому вигляді як файли розмітки ``.md`` і ``.rst``, або зі встановленим
Sphinx вони можуть зібрати документацію за допомогою Makefile (у системах Linux) для створення HTML-контенту. Потім вміст HTML можна
переглянути за допомогою веб-браузера. Ці файли ``.md`` і ``.rst`` зберігаються у
репозиторіях проекту на GitHub і обробляються для створення на сайті
``Документація проекту OPEA``.

.. Примітка:: Хоча GitHub підтримує перегляд вмісту `.md` і `.rst` за допомогою браузера на сайті `github.com`,
   розширення markdown і reST там не розпізнаються, 
   тому найкращий досвід перегляду - через сайт `Документація проекту OPEA`_ github.io.

Детальніше про розширення `reStructuredText`_ і `Sphinx`_, а також `markdown`_ і `MyST`_ ви можете прочитати на їхніх відповідних веб-сайтах.

.. _MyST extensions: https://mystmd.org/guide/quickstart-myst-markdown
.. _Sphinx extensions: https://www.sphinx-doc.org/en/stable/contents.html
.. _reStructuredText: http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html
.. _Sphinx: https://www.sphinx-doc.org
.. _Sphinx Inline Markup: https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html
.. _OPEA Project documentation:  https://opea-project.github.io
.. _markdown: https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax

У цьому документі надається короткий довідник по загальновживаним markdown і reST з директивами і ролями, визначеними MyST і Sphinx, які використовуються для створення документації, яку ви читаєте.

Markdown проти RestructuredText
*******************************

І markdown, і ReStructureText (reST) дозволяють створювати окремі файли документації, які GitHub може відображати при перегляді у браузері на github.com.
Markdown популярний завдяки своїй звичності для розробників і є мовою розмітки за замовчуванням для StackOverflow, Reddit, GitHub та інших.
ReStructuredText з'явився у спільноті Python у 2001 році і став відомим за межами цієї спільноти з виходом Sphinx у 2008 році.
Сьогодні reST підтримується GitHub, і великі проекти використовують його для своєї документації, включаючи ядро Linux, OpenCV і LLVM/Clang.

ReStructuredText є більш повнофункціональною, набагато більш стандартизованою та уніфікованою, а також має вбудовану підтримку розширень.
Мова розмітки не має стандартного способу реалізації повноцінних систем документації і не має стандартного механізму розширень,
що призводить до появи безлічі різних "смаків" розмітки. Якщо ви дотримуєтесь ядра та загального синтаксису розмітки (заголовки, абзаци, списки тощо),
використання розмітки є цілком нормальним. Однак, використання сирого HTML для форматування (наприклад, вирівнювання по центру)
або використання HTML для таблиць створює проблеми при публікації на сайті https://opea-project.github.io. 
арсер MyST надає розширення для markdown, які добре інтегруються зі Sphinx, тому ми використовуємо його як місток для вмісту markdown в рамках проекту OPEA.

У документації OPEA ми використовуємо як файли markdown, так і файли reST для документації "листів".
Ми покладаємося на reST для організації стовбура та гілок документації, використовуючи директиви reST toctree.

Організація документації
************************

Documentation is maintained and updated the same as the project's code within
the opea-project GitHub repos. There are many ``README.md`` files within the various
repos along with the other files for those components. This is good because it
keeps the relevent documentation and code for that component together.

We use the ``docs`` repo to organize the presentation of all these ``README.md``
files, along with other project related documents that are maintained in the
``docs`` repo.  The root of the generated documentation starts with the
``docs/index.rst`` file that starts off the organizational structure that's
shown as the left navigation in the generated HTML site at
https://opea-project.github.io.  That ``index.rst`` file uses a ``toctree``
directive to point to other documents that may include additional ``toctree``
directives of their own, ultimately collecting all the content into an
organizational structure you can navigate.


Заголовки
*********

.. tabs::

   .. group-tab:: reST

        У reST розділи документа ідентифікуються через їхні заголовки, виділені підкресленням під текстом заголовка.
        (Хоча reST дозволяє використовувати для позначення заголовків як підкреслення, так і відповідне підкреслення, ми використовуємо для заголовків лише підкреслення).
        Для узгодженості в нашій документації ми визначаємо порядок символів, що використовуються для позначення вкладених рівнів у змісті:

        * Використовуй ``#`` для символу підкреслення назви документа (H1)
        * Використовуй ``*`` для рівня заголовка першого підрозділу (H2)
        * Використовуй ``=`` для рівня заголовків другого підрозділу (H3)
        * Використовуй ``-`` для рівня заголовків третього підрозділу (H4)

        Додаткова глибина на рівні заголовка не рекомендується, але якщо це необхідно,
        використовуй ``%`` (H5), ``+`` (H6), and ``@`` (H7).

        Підкреслення заголовка має бути щонайменше таким же довгим, як і заголовок, під яким воно знаходиться.

        Ось приклад вкладених рівнів заголовків і відповідних підкреслень для використання:

        .. code-block:: rest

           Document Title heading
           ######################

           Section 1 heading
           *****************

           Section 2 heading
           *****************

           Section 2.1 heading
           ===================

           Section 2.1.1 heading
           ---------------------

           Section 2.2 heading
           ===================

           Section 3 heading
           *****************


   .. group-tab:: markdown

      У markdown заголовки вказуються у вигляді рядка, що починається з символу ``#``
      з додатковими символами ``#``, що вказують на більш глибокий рівень заголовка
      рівень, наприклад, ``#`` для H1 (заголовок), ``##`` для заголовків H2, ``###`` для заголовків H3
      і так далі.

      * Символ ``#`` для заголовка повинен бути першим символом у рядку, потім пробіл, а потім заголовок. Наприклад::

           # My Document's Title

           Some content goes here.

           ## First H2 heading

           Some more content

      * На початку документа має бути лише один заголовок ``#`` H1, який вказує на назву документа.
      * Ви не повинні пропускати рівні заголовків на шляху вниз в ієрархії документа, наприклад, не переходити від H1 ``#`` до H3 ``###`` без проміжного H2 ``##``.
        Ви можете пропускати рівні заголовків на зворотному шляху, наприклад, від H4 ``####`` до H2 ``##``, якщо це доречно.


Виділення вмісту
****************

Кілька поширених прикладів reST і вбудованої розмітки markdown:

* дода зірка: ``*text*`` для курсиву (*italics*),
* дві зірки: ``**text**`` для виделення (**boldface**)

.. tabs::

   .. group-tab:: reST

      * дві зворотні лапки: ````text```` для ``inline code`` зразків.

      Правила ReST для вбудованої розмітки намагаються бути поблажливими, щоб врахувати поширені випадки використання цих позначок.
      Наприклад, використання зірочки для позначення множення, наприклад, ``2 * (x + y)`` не буде інтерпретовано як нерозділений курсив.

   .. group-tab:: markdown

      * одні зворотні лапки: ```text``` для `inline code` зразків.

Для вбудованої розмітки символи між початковим і кінцевим символами не повинні починатися або закінчуватися пробілом,
тому ``*this is italics*``, (*це курсив*) в той час як ``* this isn't*`` (* це не курсив*).

Якщо зірочка або зворотні лапки з'являються у тексті, що виконується, і їх можна сплутати з розділювачами вбудованої розмітки,
ви можете усунути плутанину, додавши перед ними зворотну косу риску (``\``).


Списки
******

Для маркованих списків ставте зірочку (``*``) або дефіс (``-``) на початку абзацу і відступайте рядки продовження двома пробілами.

Перший елемент списку (або підсписку) повинен мати перед собою порожній рядок і відступ на тому ж рівні, що й попередній абзац (але не сам відступ).

Для нумерованих списків
почніть з ``1.`` or ``a)`` наприклад, і продовжуйте з автонумерацією
користуючись знаком ``#`` и  ``.`` або ``)`` як користувалися в першому елементі списку.
Відступайте рядки продовження пробілами для вирівнювання з текстом першого елемента списку:

.. code-block:: rest

   * Це маркований список.
   * Він має два елементи, другий елемент
     и має більше ніж одну строку reST тексту.  Додаткові строки
     з відступом до першого символу тексту маркованого списку.

   1. Це новий нумерований список. Якби перед ним не було порожнього рядка, він був би продовженням попереднього списку (або абзацу).
   #. Він також має два пункти.

   a) Це нумерований список з використанням алфавітних заголовків 
   #) Він має три елементи (і використовує автонумерацію для решти списку) 
   #) Ось третій елемент. Використовуйте узгоджену пунктуацію в номері списку.

   #. Це список з автоматичною нумерацією (за замовчуванням використовуються номери, що починаються з 1).

      #. Це список другого рівня під першим елементом (також з автонумерацією). Зверніть увагу на відступи.
      #. І другий елемент у вкладеному списку.
   #. І другий пункт назад у вміст списку. Порожній рядок не потрібен, але для читабельності він не зашкодить.

Списки визначень (з одним або кількома термінами та їхніми визначеннями) - це зручний спосіб задокументувати слово або фразу з поясненням. Наприклад, цей вміст reST:

.. code-block:: rest

   Makefile має цілі, які включають:

   ``html``
      Створити HTML-вивід для проекту

   ``clean``
     Видалити усі згенеровані дані, відновивши папки до чистого стану.

Буде відображено як:

   Makefile має цілі, які включають:

   html
     Створити HTML-вивід для проекту

   clean
      Видалити усі згенеровані дані, відновивши папки до чистого стану.

Багатостовпчикові списки
************************

У reST, якщо ви маєте довгий маркований список елементів, де кожен елемент є коротким,
ви можете вказати, що елементи списку слід виводити у декілька стовпчиків за допомогою спеціальної директиви ``... rst-class:: rst-columns``.
Директива буде застосована до наступного елемента, що не містить коментарів (наприклад, абзацу), або до вмісту, відступ якого визначено директивою.
Наприклад, цей невпорядкований список::

   .. rst-class:: rst-columns

   * A list of
   * short items
   * that should be
   * displayed
   * horizontally
   * so it doesn't
   * use up so much
   * space on
   * the page

буде виведено як:

.. rst-class:: rst-columns

   * A list of
   * short items
   * that should be
   * displayed
   * horizontally
   * so it doesn't
   * use up so much
   * space on
   * the page

Якщо ви використовуєте ``rst-columns`` (або ``rst-columns3``), буде показано максимум три стовпчики, а якщо ``rst-columns2`` - два стовпчики.
Кількість відображуваних стовпчиків можна зменшити залежно від доступної ширини вікна відображення,
зменшивши до одного стовпчика на вузьких (телефонних) екранах, якщо це необхідно.

.. note:: Ми відмовилися від використання директиви ``hlist``, оскільки вона погано працює на невеликих екранах.

Таблиці
*******

Існує кілька способів створення таблиць, кожен з яких має свої обмеження або особливості.
`Grid tables
<http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#grid-tables>`_
пропонують найбільше можливостей для визначення об'єднаних рядків і стовпців
(коли вміст охоплює кілька рядків або стовпців, але їх важко підтримувати, оскільки символи сітки мають бути вирівняні по всій таблиці)::

   +------------------------+------------+----------+----------+
   | Header row, column 1   | Header 2   | Header 3 | Header 4 |
   | (header rows optional) |            |          |          |
   +========================+============+==========+==========+
   | body row 1, column 1   | column 2   | column 3 | column 4 |
   +------------------------+------------+----------+----------+
   | body row 2             | ...        | ...      | you can  |
   +------------------------+------------+----------+ easily   +
   | body row 3 with a two column span   | ...      | span     |
   +------------------------+------------+----------+ rows     +
   | body row 4             | ...        | ...      | too      |
   +------------------------+------------+----------+----------+

Цей приклад буде показано як:

+------------------------+------------+----------+----------+
| Header row, column 1   | Header 2   | Header 3 | Header 4 |
| (header rows optional) |            |          |          |
+========================+============+==========+==========+
| body row 1, column 1   | column 2   | column 3 | column 4 |
+------------------------+------------+----------+----------+
| body row 2             | ...        | ...      | you can  |
+------------------------+------------+----------+ easily   +
| body row 3 with a two column span   | ...      | span     |
+------------------------+------------+----------+ rows     +
| body row 4             | ...        | ...      | too      |
+------------------------+------------+----------+----------+

Для reST, `List tables
<http://docutils.sourceforge.net/docs/ref/rst/directives.html#list-table>`_
набагато простіші в обслуговуванні, але не підтримують прольоти між рядами або колонами::

   .. list-table:: Table title
      :widths: 15 20 40
      :header-rows: 1

      * - Heading 1
        - Heading 2
        - Heading 3
      * - body row 1, column 1
        - body row 1, column 2
        - body row 1, column 3
      * - body row 2, column 1
        - body row 2, column 2
        - body row 2, column 3

Цей приклад буде показано як:

.. list-table:: Table title
   :widths: 15 20 40
   :header-rows: 1

   * - Heading 1
     - Heading 2
     - Heading 3
   * - body row 1, column 1
     - body row 1, column 2
     - body row 1, column 3
   * - body row 2, column 1
     - body row 2, column 2
     - body row 2, column 3

Параметр ``:widths:`` дозволяє визначити відносну ширину стовпців. За замовчуванням ширини стовпців однакові.
Якщо ви маєте таблицю з трьома стовпчиками і хочете, щоб перший стовпчик був удвічі меншим за інші два стовпчики однакової ширини,
ви можете вказати ``:widths: 1 2 2``. Якщо ви хочете, щоб браузер встановив ширину стовпців автоматично на основі вмісту стовпців,
ви можете використати ``:widths: auto``.


Імена файлів і команди
**********************

.. tabs::

   .. group-tab:: reST

      Sphinx розширює reST за рахунок підтримки додаткових елементів вбудованої розмітки (так званих "ролей"), 
      які використовуються для позначення тексту спеціальними значеннями та увімкнення форматування виводу. 
      (Повний список можна знайти у документації `Sphinx Inline Markup`_).

     Наприклад, існують ролі для позначення :file:`filenames` (``:file:`name``) і назв команд, таких як :command:`make` (``:command:`make``). 
     Ви також можете використовувати розмітку \'\'вбудований код\'\' (подвійні зворотні лапки) для позначення ``імені файлу''.

      Не використовуйте елементи в межах однієї зворотної мітки, наприклад, ```word```. Замість цього використовуйте подвійні бектики: ````word````.

   .. group-tab:: markdown

      MyST розширює можливості розмітки, підтримуючи додаткові вбудовані елементи розмітки (так звані "ролі"),
      які використовуються для позначення тексту спеціальними значеннями та уможливлюють форматування виводу.

Посилання на файли в гілці 
**************************

YВи можете додати в документацію посилання на певний файл у дереві GitHub.
Переконайтеся, що посилання вказує на гілку для цієї версії документації.
Наприклад, посилання у версії документації v0.8 має вказувати на файли у гілці v0.8.
Не посилайтеся на файли в головній гілці, оскільки файли в цій гілці можуть змінитися або навіть бути видалені після випуску релізу.

У reST, щоб зробити такий тип зв'язування файлів можливим, використовуйте спеціальну роль, яка створює гіперпосилання на цей файл у гілці, що перевіряється в даний момент.

.. Примітка:: Передбачається, що перевірена версія репозиторію **docs**, коли ми генеруємо HTML-документацію, є однаковою тегованою версією для всіх репозиторіїв, на які ми хочемо посилатися.

Наприклад, посилання GitHub на reST-файл, використаний для створення цього документа, можна створити за допомогою ``:docs_blob:`developer-guides/doc_guidelines``,
яке буде виглядати як :docs_blob:`developer-guides/doc_guidelines.rst``, посилання на файл "blob" у репозиторії GitHub, як це відображається GitHub.
Існує також роль ``:docs_raw:``developer-guides/doc_guidelines.rst``, яка посилатиметься на "сирий" неінтерпретований файл, :docs_raw:``developer-guides/doc_guidelines.rst``.
Перейдіть за цими посиланнями, щоб побачити різницю

Якщо ви не хочете, щоб у тексті відображався весь шлях до імені файлу, використовуйте звичайну нотацію для визначення тексту посилання,
наприклад, ``:docs_blob:`Guidelines <developer-guides/doc_guidelines.rst>``` буде показано як просто :docs_blob:`Guidelines <developer-guides/doc_guidelines.rst>`.

.. _internal-linking:

Внутрішнє перехресне посилання
******************************

.. tabs::

   .. group-tab:: reST

      Традиційні reST-посилання підтримуються лише в межах поточного файлу за допомогою нотації:

      .. code-block:: rest

         refer to the `internal-linking`_ documentation

     що виводиться як,

         refer to the `internal-linking`_ documentation

      Зверніть увагу, що використання останнього підкреслення вказує на **вихідне посилання**. У цьому
      прикладі мітку було додано безпосередньо перед заголовком, тому текст, який
      відображається, є текстом самого заголовка.

      За допомогою Sphinx ми можемо створювати посилання на будь-який тегований текст у проєктній документації.

      Розташування елементів у документах визначається за допомогою директиви label:

         .. code-block:: rst

            .. _my label name:

      Зверніть увагу на перше підкреслення, що вказує на **вхідне посилання**.
      Вміст безпосередньо після цієї мітки є ціллю для посилання ``:ref:``ім'я моєї мітки`` з будь-якого місця у наборі документації.
      Мітку **необхідно** додавати безпосередньо перед заголовком, щоб при посиланні на цю мітку можна було побачити природну фразу (наприклад, текст заголовка).

      Ця директива також використовується для визначення мітки, яка є посиланням на URL-адресу:

      .. code-block:: rest

         .. _Hypervisor Wikipedia Page:
            https://en.wikipedia.org/wiki/Hypervisor

      Щоб забезпечити легке перелинковування сторінок на сайті, кожен файл повинен мати мітку посилання перед назвою, щоб на нього можна було посилатися з іншого файлу.

      .. Примітка:: Ці посилання повинні бути унікальними для всього сайту, тому слід уникати загальних назв, таких як "зразки" або "вступ".

     Наприклад, верхня частина файлу ``.rst`` цього документа:

      .. code-block:: rst

         .. _doc_guidelines:

         Documentation Guidelines
         ########################

      Інші ``.rst`` документи можуть посилатися на цей документ за допомогою тегу ``:ref:`doc_guidelines``, і він буде відображатися як :ref:`doc_guidelines`.
      Цей тип внутрішніх перехресних посилань працює в декількох файлах. Текст посилання отримується з джерела документа,
      тому при зміні заголовка автоматично оновлюється і текст посилання.

      Бувають випадки, коли ви хочете змінити текст посилання, який відображається у створеному документі.
      У цьому випадку ви можете вказати альтернативний текст за допомогою ``:ref:`альтернативний текст <doc_guidelines>``
      (відображається як :ref:`альтернативний текст <doc_guidelines>`).

   .. group-tab:: markdown

      Зробити



Не-ASCII символи
****************

Ви можете вставляти символи не в кодуванні ASCII, наприклад, символ торговельної марки (|trade|), використовуючи позначення ``|trade|``.
(Також дозволено використовувати символи UTF-8 безпосередньо.) Доступні назви замін визначено у включаємому файлі, який використовується під час обробки reST-файлів у Sphinx.
Назви цих символів-замінників збігаються з тими, що використовуються у HTML-об'єктах для вставки спеціальних символів, таких як \&trade;, і визначені у файлі ``phinx_build/substitutions.txt'', як зазначено тут:

.. literalinclude:: ../sphinx/substitutions.txt
   :language: rst

Ми залишили невеликий список замін, але ви можете додавати інші за потреби, вносячи зміни до файлу ``substitutions.txt``.

Включення вмісту з інших файлів

Ви можете безпосередньо включити фрагмент документа з іншого файлу до вмісту reST або розмітки за допомогою директиви ``include``.

.. important:: Пам'ятайте, що посилання на вміст у включеному вмісті є відносними відносно файлу, який його включає.
   Наприклад, відносне посилання на зображення має бути коректним з точки зору файлу, що включає його, а не з точки зору включеного файлу.
   Крім того, файл, що включається, має бути доречним у контексті поточного документа на момент застосування директиви.
   Якщо фрагмент документа, що включається, містить структуру розділів, структура заголовків повинна відповідати і бути узгодженою з контекстом.

.. tabs::

   .. group-tab:: reST

      У reST ви включаєте вміст з іншого файлу за допомогою директиви include. Якщо не вказано жодних параметрів, включений файл аналізується у контексті поточного документа::

         Ось деякий текст в документі reST.

         .. include::  path/to/file

         А тепер ми повернемося до вихідного документа після вмісту у включеному файлі, так, ніби цей вміст міститься безпосередньо в поточному файлі.

      Ви можете змінити спосіб обробки включеного файлу за допомогою опцій:

      \:code\: language
         Включений вміст розглядається як ``код-блок`` з підсвічуванням ``мови``.

      \:parser\: text
        За замовчуванням включений вміст аналізується так само, як і поточний документ (наприклад, rst). Цей параметр вказує інший синтаксичний аналізатор, наприклад ``:parser: myst_parser.sphinx_``, якщо включений файл є розміткою.

      \:start-after\: text
        Буде включено лише вміст після першого входження вказаного ``тексту`` у зовнішньому файлі.

      \:end-before\:
        Буде включено лише вміст до першого входження вказаного ``тексту`` у зовнішньому файлі.

      Ці та інші опції описано у документації `docutils, що включає директиву <https://docutils.sourceforge.io/docs/ref/rst/directives.html#including-an-external-document-fragment>`_.

   .. group-tab:: markdown

         Директиви MyST можна використовувати для включення вмісту з іншого файлу в поточний документ так, ніби він є частиною поточного документа::

            ```{include} relativepath/to/file
            ```

        Параметр ``relativepath/to/file`` починається з ``/``, щоб вказати шлях, який починається з кореня дерева каталогів документів (а не з кореня базової файлової системи).
        Ви можете посилатися на файли поза коренем дерева документів, використовуючи синтаксис ``.../.../``, щоб дістатися до файлу.

        Ви можете включити зовнішній файл і показати його як кодовий блок за допомогою директиви ``literalinclude``::

           ```{literalinclude} relativepath/to/file
           ```

        Ви можете включити вміст reST, інтерпретований як reST, за допомогою директиви ``eval-rst``, використовуючи синтаксис reST та опції директиви ``include``, такі як::

           ```{eval-rst}
           .. include:: path/to-file
              :start-after: <start include marker>
              :end-before: <end include marker>
           ```


Приклади кодів і команд
***********************

.. tabs::

   .. group-tab:: reST

        Використовуйте директиву reST ``code-block`` для створення виділеного блоку тексту фіксованої ширини,
        який зазвичай використовується для показу відформатованого коду або консольних команд і виводу.
        Підтримується також розумне підсвічування синтаксису (за допомогою пакета Pygments).
        Ви також можете безпосередньо вказати мову підсвічування. Наприклад:

        .. code-block:: rest

           .. code-block:: c

              struct _k_object {
                 char *name;
                 u8_t perms[CONFIG_MAX_THREAD_BYTES];
                 u8_t type;
                 u8_t flags;
                 u32_t data;
              } __packed;

        Зверніть увагу, що між директивою ``code-block`` і першим рядком тіла кодового блоку є порожній рядок,
        а вміст тіла відступається на три пробіли (до першого непустого пробілу імені директиви).

        У цьому прикладі буде показано наступне:

        .. code-block:: c

          struct _k_object {
             char *name;
             u8_t perms[CONFIG_MAX_THREAD_BYTES];
             u8_t type;
             u8_t flags;
             u32_t data;
          } __packed;


       Для директиви ``code-block`` можна вказати інші мови, зокрема ``c``, ``python`` і ``rst``,
       а також ``console``, ``bash`` або ``hell``. Якщо ви не хочете підсвічування синтаксису, вкажіть ``none``.
       Наприклад:

        .. code-block:: rest

           .. code-block:: none

              Цей блок тексту буде стилізовано за допомогою фону та рамки, але без підсвічування синтаксису.

        Буде відображатися як:

        .. code-block:: none

          Цей блок тексту буде стилізовано за допомогою фону та рамки, але без підсвічування синтаксису.

        Існує також скорочення для написання блоків коду: закінчуйте вступний абзац подвійною двокрапкою (``::``) і відступайте вміст блоку коду трьома пробілами.
        На виході з'явиться лише одна двокрапка.

        .. Примітка:: Пакет виділення робить найкраще припущення щодо типу контенту в блоці, що може призвести до дивного виділення у згенерованому виводі.

   .. group-tab:: markdown

      У markdown для визначення кодових блоків використовуються огороджені кодові блоки.  Використовуйте три
      зворотні мітки ``````` в рядках до і після блоку коду, наприклад:

      .. code-block:: none

         ```
         {
            "firstName": "John",
            "lastName": "Smith",
            "age": 25
         }
         ```

      Вивід буде виглядати наступним чином:

      .. code-block:: none

         {
            "firstName": "John",
            "lastName": "Smith",
            "age": 25
         }

      Підсвічування синтаксису також підтримується для огороджених блоків коду, якщо вказати мову поруч із символом лапки перед огородженим блоком коду:

      .. code-block:: none

         ```json
         {
            "firstName": "John",
            "lastName": "Smith",
            "age": 25
         }
         ```

      Вивід буде виглядати наступним чином:

      .. code-block:: json

         {
            "firstName": "John",
            "lastName": "Smith",
            "age": 25
         }

      Зробити: додати список підтримуваних мов.

Зображення
**********

Ім'я файлу зображення вказується відносно файлу-джерела документа. Ми рекомендуємо розміщувати зображення в папці ``images``, де знаходиться джерело документа.
Підтримуються звичайні формати зображень, які обробляються веб-браузером: JPEG, PNG, GIF і SVG.
Розмір зображення повинен бути настільки великим, наскільки це необхідно, як правило, не менше 500 пікселів у ширину, але не більше 1000 пікселів,
 і не більше 250 КБ, якщо тільки для наочності не потрібне особливо велике зображення.

Ви також можете вказати URL-адресу файлу зображення, якщо це необхідно.

.. tabs::

   .. group-tab:: reST

        In reST, images are placed the document using an image directive::

           .. image:: ../images/opea-horizontal-color-w200.png
              :align: center
              :alt: alt text for the image

        or if you'd like to add an image caption, use the figure directive::

            .. figure:: ../images/opea-horizontal-color-w200.png
               :alt: image description

               Caption for the figure

   .. group-tab:: markdown

У markdown, зображення розміщуються в документації з використанням такого синтаксису::

          ![OPEA Logo](../images/opea-horizontal-color-w200.png)



Табуляція, пробіли та відступи
******************************

Відступи є важливими для вмісту reST-файлів, тому бажано використовувати пробіли.
Додатковий відступ може (ненавмисно) змінити спосіб відображення вмісту.
Для списків і директив відступайте текст вмісту до першого непустого пробілу у попередньому рядку.
Наприклад:

.. code-block:: rest

   * Елемент списку, який охоплює кілька рядків тексту, із зазначенням місця відступу від рядка продовження.

   1. А для нумерованих елементів списку рядок продовження повинен бути вирівняний з текстом рядка вище.

   .. code-block::

      Текст у блоці директив має бути вирівняний за першим символом назви директиви.

Не перевищуйте довжину рядка документації до 80 символів, щоб полегшити її перегляд на GitHub.
Довгі рядки через посилання на URL-адреси є дозволеним винятком.

Кольори фону
************

Ми визначили деякі стилі CSS для використання у якості кольорів фону для абзаців.
Ці стилі можна застосувати за допомогою директиви ``...rst-class`` з використанням однієї з цих назв стилів.
Ви також можете використовувати визначений стиль ``centered`` для розміщення тексту по центру елемента,
корисний для центрування тексту у комірці таблиці або діапазоні стовпців:

.. rst-class:: bg-opea-lightorange centered

   \.\. rst-class:: bg-opea-lightorange centered

.. rst-class:: bg-opea-darkorange centered

   \.\. rst-class:: bg-opea-darkorange centered

Креслення
*********

.. tabs::

   .. group-tab:: reST

      У reST ми включили розширення ``graphviz`` Sphinx, щоб дозволити цій мові опису тексту відтворювати малюнки.
      Докладнішу інформацію наведено на сторінці :ref:`graphviz-examples`..

     Ми також включили розширення з підтримкою ``mermaid``, яке також дозволяє цій мові опису тексту відтворювати малюнки за допомогою::

         .. mermaid::

            graph LR;
              A--> B & C;
              B--> A & C;
              C--> A & B;

      Це буде відображено на цьому графічному малюнку:

      .. mermaid::

         graph LR;
           A--> B & C;
           B--> A & C;
           C--> A & B;

      Для отримання додаткової інформації див. `Посібник користувача Mermaid <https://mermaid.js.org/intro/getting-started.html>`_.

   .. group-tab:: markdown

      У markdown ми включили розширення MyST ``mermaid``, щоб увімкнути цю текстову
      мову опису тексту для відображення креслень за допомогою::

         ```{mermaid}
         graph LR;
           A--> B & C & D;
           B--> A & E;
           C--> A & E;
           D--> A & E;
           E--> B & C & D;
         ```

      Це буде відображено на цьому графічному малюнку:

      .. mermaid::

         graph LR;
           A--> B & C & D;
           B--> A & E;
           C--> A & E;
           D--> A & E;
           E--> B & C & D;

      Для отримання додаткової інформації див. `Посібник користувача Mermaid <https://mermaid.js.org/intro/getting-started.html>`_.

Альтернативний вміст вкладок
****************************

У ResST замість того, щоб створювати кілька документів зі спільним матеріалом, за винятком деяких специфічних розділів,
ви можете написати один документ і надати читачеві альтернативний контент за допомогою інтерфейсу з вкладками.
Коли читач натискає на вкладку, відображається вміст цієї вкладки. Наприклад::

   .. tabs::

      .. tab:: Apples

         Apples are green, or sometimes red.

      .. tab:: Pears

         Pears are green.

      .. tab:: Oranges

         Oranges are orange.

відобразиться як:

.. tabs::

   .. tab:: Apples

      Apples are green, or sometimes red.

   .. tab:: Pears

      Pears are green.

   .. tab:: Oranges

      Oranges are orange.

Вкладки можна також згрупувати так, щоб зміна поточної вкладки в одній області змінювала всі однойменні вкладки на всій сторінці. Наприклад:

.. tabs::

   .. group-tab:: Linux

      Linux Line 1

   .. group-tab:: macOS

      macOS Line 1

   .. group-tab:: Windows

      Windows Line 1

.. tabs::

   .. group-tab:: Linux

      Linux Line 2

   .. group-tab:: macOS

      macOS Line 2

   .. group-tab:: Windows

      Windows Line 2

В останньому випадку ми використовуємо директиву ``... group-tab::`` замість
директиву ``.. tab::``.  Під капотом ми використовуємо розширення `phinx-tabs
<https://github.com/djungelorm/sphinx-tabs>`_ розширення, яке включено
у файлі OPEA docs (requirements.txt).  У межах вкладки ви можете мати майже будь-який вміст
будь-який вміст *крім заголовка* (кодові блоки, впорядковані та невпорядковані
списки, зображення, абзаци тощо).

Кроки інструкції
****************

У reST стиль нумерованих кроків інструкцій дозволяє легко створювати посібники з чітко визначеними кроками.
Додайте директиву ``...rst-class:: numbered-step`` безпосередньо перед заголовком другого рівня 
(за правилами проекту, заголовком, підкресленим зірочками ``******``), і він буде показаний як нумерований крок, послідовно пронумерований у документі. 
(Заголовки другого рівня без цієї директиви ``rst-class`` не нумеруватимуться).
Наприклад::

   .. rst-class:: numbered-step

   Put your right hand in
   **********************

.. rst-class:: numbered-step

Перший крок інструкції
**********************

Це перший крок інструкції. Ви можете використовувати звичайні абзаци та малюнки, як ви використовуєте при написанні звичайних документів.
Напишіть заголовок, який має бути коротким викладом суті кроку (нумерація кроків автоматизована, тому ви можете легко переміщатися по кроках, якщо це необхідно).

.. rst-class:: numbered-step

Другий крок інструкції
**********************

Це другий крок інструкції.

.. Примітка:: Як реалізовано, для кожного документа передбачено лише один набір пронумерованих кроків, і ці кроки мають бути заголовками 2-го рівня.


Створення документації
**********************

Для отримання інструкцій щодо створення документації дивиться :ref:`opea_doc_generation`.
